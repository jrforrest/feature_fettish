(empty "")
(not (empty ""))
(not (empty? ""))
(-> "" empty? not)
(-> "sdlfj" empty? not)
(->> "" not empty?)
(->> "" not empty? )
(->> "" not )
(-> "" not )
(if false (prn "hi"))
(subreddit-aggregate-wordcounts "programming" 1)
(e)
(subreddit-aggregate-wordcounts "programming" 1)
(empty? nil)
(subreddit-aggregate-wordcounts "programming" 1)
(subreddit-posts "programming" 1)
(require feat_fettish.dict-search)
(require feat_fettish.core)
(require 'feat_fettish.core)
(require 'feat_fettish.dict-search)
(fuggof)
(fuggoff)
(require 'feat_fettish.dict-search)
(fuggoff)
(in-ns dict-search)
(in-ns feat_fettish.dict-search)
(require 'feat-fettish.dict-search)
(require 'feat_fettish.dict-search)
(in-ns feat_fettish.dict-search)
(in-ns feat_fettish.dict_search)
(require 'feat-fettish.dict-search)
(require 'feat_fettish.dict-search)
(feat_fettish.dict-search/fuggof)
(< "aaa" "bbb")
(compare "aaa" "bbb")
(compare "bbb" "bbb")
(compare "ccc" "bbb")
(- 5  3)
(strip  "  sldfkj sldfkj")
(clojure.string/strip  "  sldfkj sldfkj")
(second ('one 'two))
(second '('one 'two))
(second '(1 2))
(empty? nil)
(compare "slokfjskldfsoi" "lsdkfjklsdjfkdsfls")
(compare "slokfjskldfsoiwwowowowowoowwo" "lsdkfjklsdjfkdsfls")
(< 0 4)
(< 0 -4)
(:start nil)
(defn try
(let [a 1]
recur))
(defn try
[]
(let [a 1]
recur))
(defn try [] (let [a 1] recur))
(defn try [] (let [a 1] (recur)))
(- 5 2)
(> 1 0)
(defn hi [] (if true (recur)))
(use 'clojure.contrib.trace)
(use 'clojure.trace)
(use clojure.contrib.trace)
(use 'clojure.tools.trace)
(dotrace in-dict? "Thomas")
(dotrace (in-dict? "Thomas"))
(in-ns feat_fettish.dict-search)
(in-ns 'feat_fettish.dict-search)
(dotrace (in-dict? "Thomas"))
(dotrace [in-dict?] (in-dict? "Thomas"))
(use 'clojure.tools.trace)
(dotrace [in-dict?] (in-dict? "Thomas"))
(dotrace (in-dict? "Thomas"))
(dotrace '(in-dict? "Thomas"))
(dotrace [in-dict?] (in-dict? "Thomas"))
(dotrace [in-dict? binary-search-file-window] (in-dict? "Thomas"))
(> 0 234234)
(dotrace [in-dict? binary-search-file-window] (in-dict? "Thomas"))
(dotrace [in-dict? binary-search-file-window] (in-dict? "slkfjsklfoewrowrje"))
(dotrace [in-dict? binary-search-file-window] (in-dict? "penis"))
(dotrace [in-dict? binary-search-file-window] (in-dict? "Gerald"))
(dotrace [in-dict? binary-search-file-window] (in-dict? "tank"))
(dotrace [in-dict? binary-search-file-window blah] (in-dict? "tank"))
(dotrace [in-dict? binary-search-file-window midpoint] (in-dict? "tank"))
(dotrace [in-dict? binary-search-file-window blah] (in-dict? "tank"))
(- 2 1)
(dotrace [in-dict? binary-search-file-window blah] (in-dict? "tank"))
(dotrace [in-dict? binary-search-file-window blah] (in-dict? "cast"))
(dotrace [in-dict? binary-search-file-window blah] (in-dict? "cassssst"))
(dotrace [in-dict? binary-search-file-window blah] (in-dict? "A"))
(dotrace [in-dict? binary-search-file-window blah] (in-dict? "Ã©tudes"))
(dotrace [in-dict? binary-search-file-window blah] (in-dict? "cat"))
(in-dict? "cat")
jh
(call #())
(apply #())
(apply #(prn "hello!") [])
(apply #(prn "hello!") )
(apply #(prn "hello!") nil)
(defn hi
[]
(let [word "hi"]
(fn [] (prn word))))
(hi)
(apply (hi) nil)

(map key {:one :two})
(delete-if #(= "penis" (key %)) {"penis" :one :two :three})
(select-keys #(= "penis" (key %)) {"penis" :one :two :three})
(-> {:one :two}
(map key))
#(map key %))
(-> {:one :two} #(map key %))
(map key {:one :two})
(-> {:one :two} (map key))
(call #(true))
(apply #(true))
(apply #(true) nil)
(key {"penis" 2})
(map key {"penis" 2})
(map key (first {"penis" 2}))
(map key {"penis" 2 "whatevs" 3)
(map key {"penis" 2 "whatevs" 3})
(keys {"penis" 2 "whatevs" 3})
(get "penis" {"penis" 2})
(get "iou" {"winners" 2})
(vector 'one 'two)
(hash-map [['one 'two']]
)
(vec {:one :two})
(first {:one :two})
(val {:one :two})
(reduce + {:one 1 :two 2})
(vec {:one :two})
(vec {:one :two :three :four})
(vector {:one :two :three :four})
(keys {:one :two :three :four})
(concat [[:one :two] [:three :four]])
(set)
(set [])
(make-set)
(set nil)
(set [[:one :two] [:three :four]]
)
(fn)
(reduce prn {:one :two :three :four})
(last [:one])
(reduce #(assoc % (first %2) 1) (hash-map) {:one :two :three :four})
(fn [one]
"hello"
"shityeah")
(fn "hi" [one] "shityeah")
(defn hi
[word]
(fn [] word))
((hi))
((hi "ldksjf"))
(< 3 4)
(> 3 4)
0.6
(remove #(zero ? %2) {:one 0 :two 1})
(remove #(zero? %2) {:one 0 :two 1})
(remove #(zero? %1) {:one 0 :two 1})
(remove #(zero? (value %1)) {:one 0 :two 1})
(remove #(zero? (val %1)) {:one 0 :two 1})
(map (remove #(zero? (val %1)) {:one 0 :two 1}))
(hash-map (remove #(zero? (val %1)) {:one 0 :two 1}))
(into {} (remove #(zero? (val %1)) {:one 0 :two 1}))
(into {} (keep #(zero? (val %1)) {:one 0 :two 1}))
(keep #(zero? (val %1)) {:one 0 :two 1})
(into {} (filter #(zero? (val %1)) {:one 0 :two 1}))
(map prn {:one :two})
(map prn {:one :two :three :four})
(map #(%) {:one :two :three :four})
(map prn {:one :two :three :four})
(map #(%) {:one :two :three :four})
(map (fn [ele] ele) {:one :two :three :four})
(lower-case "HellowW")
(clojure.string/lower-case "HellowW")
(clojure.string/replace "F2$#435hawf Yeah!" #"[^\w]" "")
(cons :one :two)
(defn- iter
[]
(let [x 1]
))
(next ())
(next (:one))
(next ('one))
(next (seq 'one))
(next (seq ['one]))
(next (seq ['one 'two 'three]))
(first nil)
(first ())
(first (seq []))
(seq [])
()
(nil? ())
(empty? nil)
(require 'clojure.tools.logging)
(require 'org.clojure/tools.logging)
(require 'clojure.tools.logging)
(require 'clojure.tools.logging :as log)
(require 'clojure.tools.logging :as 'log)
(require 'clojure.tools.logging)
(clojure.tools.logging/info "hello!")
(concat "one" "two")
(clojure.string/join "one" "two")

(map #(-> % (.replaceAll #"[^\w]" "") string/losercase) ["FuckyouS2@#%$@n" "loSldfkj"])
(map #(-> % (.replaceAll #"[^\w]" "") clojure.core.string/losercase) ["FuckyouS2@#%$@n" "loSldfkj"])
(map #(-> % (.replaceAll #"[^\w]" "") clojure.core.string/lowercase) ["FuckyouS2@#%$@n" "loSldfkj"])
(map #(-> % (.replaceAll #"[^\w]" "") clojure.string/lowercase) ["FuckyouS2@#%$@n" "loSldfkj"])
(map #(-> % (.replaceAll #"[^\w]" "") clojure.string/lower-case) ["FuckyouS2@#%$@n" "loSldfkj"])
(str "one" "two")
(in-ns feat_fettish.reddit-scraper)
(in-ns :feat_fettish.reddit-scraper)
(in-ns 'feat_fettish.reddit-scraper)
(persist-posts (take 5 (subreddit-posts "programming")))
(info "hi")
(debug "hi")
(log/info "hi")
(log/debug "hi")
(persist-posts (take 5 (subreddit-posts "programming")))
(get-post-by-url "http://www.barbie.com/vote/")
(persist-posts (take 5 (subreddit-posts "relationships")))
(in-ns feat_fettish.reddit-scraper)
(in-ns 'feat_fettish.reddit-scraper)
(take 5 (subreddit-posts "relationships"))
(with-body {:url "http://reddit.com"})
(with-body {:url "google.com"})
(with-body {:url "http://google.com"})
(with-body {:url "http://en.wikipedia.org/wiki/Speed_racer"})
(take 5 (subreddit-posts "programming"))
(take 5 (subreddit-posts "relationships"))
(take 10 (subreddit-posts "programming"))
(take 10 (subreddit-posts "relationships"))
(take 10 (subreddit-posts "linux"))
(in-ns feat_fettish..post-set)
(in-ns 'feat_fettish..post-set)
(make-postset "linux-posts" (take 10 (feat_fettish.reddit-scraper/subreddit-posts "linux")))
(in-ns 'feat_fettish.post-set)
(make-postset "linux-posts" (take 10 (feat_fettish.reddit-scraper/subreddit-posts "linux")))
(add-post)
(feat_fettish.post-set/add-post)
(in-ns 'feat_fettish.whatevs)
(feat_fettish.post-set/add-post)
(make-postset "linux-posts" (take 10 (feat_fettish.reddit-scraper/subreddit-posts "linux")))
(in-ns 'feat_fettish.post-set)
(make-postset "linux-posts" (take 10 (feat_fettish.reddit-scraper/subreddit-posts "linux")))
(def ps (make-postset "linux-posts" (take 10 (feat_fettish.reddit-scraper/subreddit-posts "linux"))))
(save-posetset ps)
(save-postset ps)
(set)
(make-set)
(set [])
l
(get "one" {"one" "two"})
(get 1 {1 "two})
"
})
(get 1 {1 "one"})
(in-ns jj
)
(let [[one two] [1 2]]
(prn one)
(prn two))
(deincrement 1)
(dinc 1)
(inc 1)
(- 5 1)
(<= -2 0)
(list 'one (list 'two 'three))
(list 'one @(list 'two 'three))
(list 'one ~@(list 'two 'three))
(flatten (list 'one (list 'two 'three)))
(apply prn ("one" "two"))
(prn "one")
(prn "one" "two")
(* [1] [2])
kjsf

kj
clojure.stacktrace
(clojure.stacktrace)
(:require 'clojure.stacktrace)
(clojure.stacktrace)
(clojure.stacktrace/e)
(range 5)
(-  5 1)
(clojure.stacktrace)
(rand)
(prn (for [j (range 10)))
(prn (for [j (range 10))))
(prn (for [j (range 10))
(prn (for [j (range 10)))
(prn (for [j (range 10)]))
(prn (for [j (range 10)] j))
(def a (get-postset "programming"))
(def a (feat_fettish.post-set/get-postset "programming"))
a
(make-hash)
(hash-map :one "two")
(apply hash-map (:one "two"))
(apply hash-map (list :one "two"))
(feat_fettish.core/subreddit-factorized "programming")
(require 'clojure.stacktrace)
(e)
(use clojure.stacktrace)
(require clojure.stacktrace)
(require 'clojure.stacktrace)
(usee 'clojure.stacktrace)
(use 'clojure.stacktrace)
(e)
(feat_fettish.core/subreddit-factorized "programming")
j
(feat_fettish.core/subreddit-factorized "programming")
(subreddit-factorized "programming")
(feat_fettish.core/subreddit-factorized "programming")
(take 1 ['hi 'world])
(feat_fettish.test-posts/make-test-posts)
(feat_fettish.core/subreddit-factorized "programming")
(range 10)
(length [1 2 5])
(count [1 2 5])
(feat_fettish.core/subreddit-factorized "programming")
j
(e)
(require 'org.httpkit.server)
(defn heller [req]
{:status 200, :body "shityeah"})
(run-server heller {:port 8080})
(org.httpkit.server/run-server heller {:port 8080})
(continuously 5)
(constantly 5)
((contantly 5) 'one)
((constantly 5) 'one)
(in-ns feat_fettish.core)
(in-ns 'feat_fettish.core)
(subreddit-factorized "programming")
(vec 'one 'two)
(vector 'one 'two)
(map #([%]) ['one 'two])
(map #(vector %) ['one 'two]
)
(concat "Hello" "world!")
(concat ['one] ['two])
(vec ('one 'two)
)
(vector ('one 'two))
(vec (:one :two))
(vec '(:one :two))
(vec (first ['one 'two]))
(conj 'one ['two'])
(conj :one ['two])
(conj ['two] :one)
(hiccup.core/html [[:h3 "hi"]])
(seq 'one 'two)
(apply prn 'one ['two 'three])
(concat ('one) ('two)
)
(concat '(one) '(two))
(flatten ['one] ['two]
)
(concat [['one] ['two]])
(reduce concat [] [['one] ['two]])
(concat "Feature #" 1)
(str "Feature #" 1)
(apply vector ['one])
(apply vector ['one] [['two]])
(apply vector ['one] [['two]] [[['three ]]])
(concat [:tr] [[:td] [:td]])
(apply vector :one :two [:three :four])
(apply vector :tr [:one] [[:two] [:three]])
(vector :tr [:one] [:two])
(vector :tr [:one] [[:two]])
(apply vector :tr [:one] [[:two]])
(apply vector :table.features [[:tr] [:tr]])
(in-ns feat_fettish.core)
(in-ns 'feat_fettish.core)
(subreddit-factorized "programming")
(feat_fettish.core/subreddit-factorized "programming")
(require 'feat_fettish.core)
(subreddit-factorized)
(subreddit-factorized "programming")
(require 'feat_fettish.core)
(subreddit-factorized "programming")
(feat_fettish.display-server/run-server)
(subreddit-factorized "programming")
(in-ns 'feat_fettish.word-matrix.clj)
(rand-matrix 5 5)
(feat_fettish.word-matrix/rand-matrix 5 5)
(in-ns rand-matrix)
(require 'feat_fettish.word-matrix)
(clojure.core/require 'feat_fettish.word-matrix)
(in-ns rand-matrix)
(in-ns 'feat_fettish.word-matrix.clj)
(rand-matrix 5 5)
(in-ns clojure.core)
(in-ns 'clojure.core)
(feat_fettish.core/subreddit-factorized "programming")
(remove nil? ['one nil 'two])
(feat_fettish.core/subreddit-factorized "programming")
(Math/log 5)
(hash-map)

(in-ns feat_fettish.core
(subreddit-factorized "programming"))
(in-ns 'feat_fettish.core)
(subreddit-factorized "programming"))
(subreddit-factorized "programming")
(require 'feat_fettish.core)
(in-ns feat_fettish.core)
(e)
(require clojure.stacktrace)
(require 'clojure.stacktrace)
(e)
(use 'clojure.stacktrace)
(e)
(in-ns feat_fettish.core)
(in-ns 'feat_fettish.core)
(subreddit-factorized "programming")
(e)
(use 'clojure.stacktrace)
(subreddit-factorized "programming")
(e)
(subreddit-factorized "programming")
(e)
(subreddit-factorized "programming")
(e)
(e)
(subreddit-factorized "programming")
(e)
(subreddit-factorized "programming")
(feat_fettish.display-server/run-server)
(subreddit-factorized "programming")
(e)
(subreddit-factorized "programming")
(e)
(subreddit-factorized "programming")
(e)
(subreddit-factorized "programming")
(e)
(subreddit-factorized "programming")
(subreddit-factorized "programming" :n-posts 100)
(e)
(e 100))
(e 100)
(e)
(subreddit-factorized "programming" :n-posts 100)
(e)
(subreddit-factorized "programming" :n-posts 100)
(subreddit-factorized "programming" :n-posts 500)
(str nil)
(subreddit-factorized "programming" :n-posts 500)
(set \o \t)
(set 'one 'two)
(hash-set 'one 'two)
(char "osdnf")
(map char "sodfn")
(chars "sdlkfj")
(chars "slkfj")
(Math.ceil 2.4)
(Math/ceil 2.4)
(sort \a \b \d \c)
(sort (list \a \b \d \c))
(= ['one 'two] ['one 'two])
(str [\a \b \c])
(hash-set (vals {:one 'two :three 'fore}))
(hash-set (vals {:one #{'two} :three #{'fore}}))
(sh-set (vals {:one #{'two} :three #{'fore}}))
(set (vals {:one #{'two} :three #{'fore}}))
(subreddit-factorized "programming" :n-posts 500)
(e)
(print-cause-trace)
(.printStackTrace *e*)
(.printStackTrace *e)
(subreddit-factorized "programming" :n-posts 500)
(.printStackTrace *e)
(subreddit-factorized "programming" :n-posts 500)
(> 400 200)
(next ())
(rest ())
(subreddit-factorized "programming" :n-posts 500)
(sym one)
(symbol)
(symbol one)
(symbol "one")
(quote one two three)
(quote (one two three))
(subreddit-factorized "programming" :n-posts 500)
(in-ns 'feat_fettish.core)
(subreddit-factorized "programming" :n-posts 500)
(in-ns 'feat_fettish.core)
(in-ns feat_fettish.core)
(subreddit-factorized "programming" :n-posts 500)
(feat_fettish.display-server/run-server)
(prn 'one 'two @('three 'four))
(prn 'one 'two ~@('three 'four))
(prn 'one 'two (list 'three 'four))
